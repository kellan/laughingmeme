---
id: 725
title: 'App Logic with PEAR Errors'
date: '2004-02-02T00:07:28+00:00'
author: Kellan
layout: post
guid: 'http://lm.quxx.info/?p=725'
permalink: /2004/02/02/app-logic-with-pear-errors/
typo_id:
    - '723'
mt_id:
    - '1707'
link_related:
    - ''
raw_content:
    - "<p>\nA quick thought which I need to explore some more, but I thought I\\'d write it down. (it is worrying when you can\\'t sleep for thoughts of PHP authentication, front controllers, and PEAR error handlers)\n</p>\n<p>\nAll of the examples of custom PEAR error handlers I\\'ve ever see (of which <a href=\\\"http://www.asiatica.org/~ludo/archive/2003/08/PHP_ErrorHandling.html\\\">Ludoo\\'s is the clearest</a>) all show using them for a better pretty print.  Some talk about having them do logging, or fire off an email.  But is anyone using them to implement application logic?\n</p>\n<p>\n<a href=\\\"http://www.martinfowler.com/eaaCatalog/frontController.html\\\">Front controllers</a> are a lovely design pattern for web apps, but a number of people have argued they <a href=\\\"http://phppatterns.com/index.php/article/articleview/81/1/1/\\\">aren\\'t suited to PHP</a> (and PHP is not suited to them).  Which is a shame, because they\\'re really useful for a number of task.  One of those is enforcing proper credentials, and dealing with authentication/authorization failures intelligently.\n</p>\n<p>\nSeems like you could get the intelligent dispatching aspect of a front controller, without having to front load your authorization knowledge or give up your page centric development model.\n</p>\n<p>\nAt the beginning of your script you have some check like:\n\n<pre>\n$user = $auth->valid_user();\nif (not $user) {\n   $this->throwError(\\'Unknown user\\', AUTH_FAILURE_UNKNOWN, array( \\'referer\\' => \\'my_script.php\\') );\n}\nelseif (not $user->can_do_foo() ) {\n   $this->throwError(\\\"I\\'m sorry but you don\\'t have permission to foo\\\", AUTH_FAILURE_INSUFFICIENT_PERMS );\n}\n</pre>\n... meanwhile over in auth.php\n<pre>\ndefine(\\'AUTH_FAILURE_UNKNOWN\\', 1001);\ndefine(\\'AUTH_FAILURE_INSUFFICIENT_PERMS\\', 1002);\n...\nfunction valid_user {\n...check cookies, session vars, whatever....\n}\n</pre>\n... and then the error handler does something like ...\n\n<pre>\nfunction errorHandler($err) {\n   if ( $err->getCode == AUTH_FAILURE_UNKNOWN ) {\n\t... take user to login page, \n        .... then send them back to attempted action using \\'referer\\' var\n   }\n   elseif ( $err->getCode == AUTH_FAILURE_INSUFFICIENT_PERMS ) {\n        ... maybe take them to a warning page?\n         ... or merely return the error for inline display\n   }\n   else {\n     return, print, die, whatever works for your app\n   }\n}\n</pre>\n</p>\n<p>\nDid you notice the hand waving? (\\\"Its all hand waving Kellan!\\\", yes but some it more then most)  How do we \\\"take the user\\\" somewhere?  And ensure that the proper flow of the app is maintained?  After all these aren\\'t real exceptions, flow isn\\'t going to terminate here.  There are two solutions.  \n</p>\n<p>\nIf you\\'ve been good, I mean <b>really</b> good, and you know that you haven\\'t sent any data back to the user yet (this includes blank lines that somehow got sucked in by your cascading includes) then you can use header(\\\"Location: $login_page\\\") to redirect the user.  An example of when you might have been this good is when you\\'ve mandated that all content is generated by template files, after all the logic has completed, and even then. \n</p>\n<p>\nAnother option which I just realized tonight, which got me started writing all this, and is of course obvious, but I hadn\\'t thought of it is to simple do something like\n<pre>\nelseif ( $err->getCode == AUTH_FAILURE_INSUFFICIENT_PERMS ) {\n   include(\\'you-dont-have-that-kind-access.php\\');\n   exit;\n}\n</pre>\nI tend to think of PHP\\'s exit, which a synonym for die() in terms of Perl\\'s die, which is used to flag untoward circumstances, but in fact PHP apps can exit without it being an indication of anything the matter.\n</p>\n<p>\nYou can argue that all this error handling, and indirection increase the \\\"magic factor\\\" of your script, but for my money I think this would be a huge win in terms of readability, and centralization of logic without requiring one to buy into to an entire MVC framework.\n</p>"
---

A quick thought which I need to explore some more, but I thought I’d write it down. (it is worrying when you can’t sleep for thoughts of PHP authentication, front controllers, and PEAR error handlers)

All of the examples of custom PEAR error handlers I’ve ever see (of which [Ludoo’s is the clearest](http://www.asiatica.org/~ludo/archive/2003/08/PHP_ErrorHandling.html)) all show using them for a better pretty print. Some talk about having them do logging, or fire off an email. But is anyone using them to implement application logic?

[Front controllers](http://www.martinfowler.com/eaaCatalog/frontController.html) are a lovely design pattern for web apps, but a number of people have argued they [aren’t suited to PHP](http://phppatterns.com/index.php/article/articleview/81/1/1/) (and PHP is not suited to them). Which is a shame, because they’re really useful for a number of task. One of those is enforcing proper credentials, and dealing with authentication/authorization failures intelligently.

Seems like you could get the intelligent dispatching aspect of a front controller, without having to front load your authorization knowledge or give up your page centric development model.

At the beginning of your script you have some check like:

```

$user = $auth->valid_user();
if (not $user) {
   $this->throwError('Unknown user', AUTH_FAILURE_UNKNOWN, array( 'referer' => 'my_script.php') );
}
elseif (not $user->can_do_foo() ) {
   $this->throwError("I'm sorry but you don't have permission to foo", AUTH_FAILURE_INSUFFICIENT_PERMS );
}
```

… meanwhile over in auth.php

```

define('AUTH<em>FAILURE</em>UNKNOWN', 1001);
define('AUTH<em>FAILURE</em>INSUFFICIENT<em>PERMS', 1002);
...
function valid</em>user {
...check cookies, session vars, whatever....
}
```

… and then the error handler does something like … ```

function errorHandler($err) {
   if ( $err->getCode == AUTH_FAILURE_UNKNOWN ) {
    ... take user to login page, 
        .... then send them back to attempted action using 'referer' var
   }
   elseif ( $err->getCode == AUTH_FAILURE_INSUFFICIENT_PERMS ) {
        ... maybe take them to a warning page?
         ... or merely return the error for inline display
   }
   else {
     return, print, die, whatever works for your app
   }
}
```

Did you notice the hand waving? (“Its all hand waving Kellan!”, yes but some it more then most) How do we “take the user” somewhere? And ensure that the proper flow of the app is maintained? After all these aren’t real exceptions, flow isn’t going to terminate here. There are two solutions.

If you’ve been good, I mean **really** good, and you know that you haven’t sent any data back to the user yet (this includes blank lines that somehow got sucked in by your cascading includes) then you can use header(“Location: $login*page”) to redirect the user. An example of when you might have been this good is when you’ve mandated that all content is generated by template files, after all the logic has completed, and even then.*

Another option which I just realized tonight, which got me started writing all this, and is of course obvious, but I hadn’t thought of it is to simple do something like

```

elseif ( $err->getCode == AUTHFAILURE<em>INSUFFICIENT</em>PERMS ) {
   include('you-dont-have-that-kind-access.php');
   exit;
}
```

I tend to think of PHP’s exit, which a synonym for die() in terms of Perl’s die, which is used to flag untoward circumstances, but in fact PHP apps can exit without it being an indication of anything the matter. You can argue that all this error handling, and indirection increase the “magic factor” of your script, but for my money I think this would be a huge win in terms of readability, and centralization of logic without requiring one to buy into to an entire MVC framework.